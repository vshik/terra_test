if "messages" not in st.session_state:
    st.session_state.messages = [
        {"role": "system", "content": f"""
You are a FinOps assistant. You have access to these MCP tools:

{json.dumps(MCP_TOOLS, indent=2)}

Follow this format strictly:
Output ONLY JSON like:
{{ "tool": "<tool_name>", "params": {{ ... }} }}

Rules:
1Ô∏è‚É£ If no tool applies, output: {{ "tool": "none" }}
2Ô∏è‚É£ Do NOT write SQL or use prose.
3Ô∏è‚É£ Use exact tool names from the list.
4Ô∏è‚É£ All keys must be double-quoted JSON.
5Ô∏è‚É£ No markdown, no extra text.
"""}
    ]


# -------------------------------------------------------------
# LLM helper ‚Äì enforce strict JSON mode
# -------------------------------------------------------------
async def send_to_llm(messages, expect_json=False):
    if expect_json:
        response = await llm_client.chat.completions.create(
            model=MODEL_NAME,
            messages=messages,
            response_format={"type": "json_object"}  # ‚úÖ Hard-enforce JSON mode
        )
    else:
        response = await llm_client.chat.completions.create(
            model=MODEL_NAME,
            messages=messages
        )
    return response.choices[0].message.content.strip()


# -------------------------------------------------------------
# JSON normalization ‚Äì fix synonyms and variants
# -------------------------------------------------------------
def normalize_tool_json(raw: str) -> dict:
    """Force output to use {tool, params} keys only."""
    cleaned = raw.strip().replace("'", '"')

    try:
        data = json.loads(cleaned)
    except json.JSONDecodeError:
        return {"tool": "none"}

    # üîß Normalize synonyms
    if "action" in data and "tool" not in data:
        data["tool"] = data.pop("action")

    if "parameters" in data and "params" not in data:
        data["params"] = data.pop("parameters")

    # üîß Handle missing params key
    if "params" not in data:
        data["params"] = {}

    return data

# Step 1: Ask GPT which tool to call, using strict JSON mode
tool_prompt = [
    {"role": "system", "content": "Decide which MCP tool to call. Output valid JSON only."},
    {"role": "user", "content": user_message}
]
raw_response = await send_to_llm(tool_prompt, expect_json=True)  # ‚úÖ enforce JSON
tool_info = normalize_tool_json(raw_response)



from fastmcp import Client as MCPClient  # Make sure fastmcp is installed

async def call_mcp_tool(tool_name, params):
    """Call an MCP tool using FastMCP's native client protocol."""
    try:
        async with MCPClient(MCP_SERVER_URL) as mcp:
            result = await mcp.call_tool(tool_name, params)
            return result
    except Exception as e:
        return f"Error calling MCP tool '{tool_name}': {e}"


from fastmcp import Client as MCPClient

async def call_mcp_tool(tool_name, params):
    """Call an MCP tool using FastMCP's native client protocol."""
    try:
        async with MCPClient(MCP_SERVER_URL) as mcp:
            # ‚úÖ Wrap params correctly
            payload = {"params": params} if isinstance(params, dict) else {"params": {}}
            result = await mcp.call_tool(tool_name, payload)
            return result
    except Exception as e:
        return f"‚ùå Error calling MCP tool '{tool_name}': {e}"

SELECT
  id,
  name,
  JSON_VALUE(tags, '$.abc') AS abc_value,
  JSON_VALUE(tags, '$.def') AS def_value
FROM my_table
WHERE JSON_VALUE(tags, '$.abc') = 'value1'
  AND JSON_VALUE(tags, '$.def') = 'value2';


-- Target values
DECLARE @abc_target NVARCHAR(100) = 'value1';
DECLARE @def_target NVARCHAR(100) = 'value2';

SELECT
    id,
    name,
    -- Convert single quotes to double quotes to make valid JSON
    JSON_VALUE(REPLACE(tags, '''', '"'), '$."abc-123"') AS abc_value,
    JSON_VALUE(REPLACE(tags, '''', '"'), '$."def-456"') AS def_value
FROM my_table
WHERE
    -- Only process rows where JSON_VALUE can extract something
    JSON_VALUE(REPLACE(tags, '''', '"'), '$."abc-123"') = @abc_target
    AND JSON_VALUE(REPLACE(tags, '''', '"'), '$."def-456"') = @def_target;

